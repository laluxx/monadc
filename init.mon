;;; Variables

;; (define i 20)                   ; Inferred Int
;; (define f 40.0)                 ; Inferred Float
;; (define c 'c')                  ; Inferred Char
;; (define s "string")             ; Inferred String
;; (define h 0xFF)                 ; Inferred Hex (255)
;; (define b 0b1010)               ; Inferred Bin (10)
;; (define o 0o755)                ; Inferred Oct (493)
(define [i :: Int] 20)          ; Typed Int
(define [f :: Float] 40.0)      ; Typed Float
(define [c :: Char] 'A')        ; Typed Char
(define [s :: String] "string") ; Typed String
(define [h :: Hex] 0xFF)        ; Typed Hex (255)
(define [b :: Bin] 0b1010)      ; Typed Bin (10)
(define [o :: Oct] 0o755)       ; Typed Oct (493)

;; TODO
;; (show "Value of i is _ f is _ and o is _" i f o)

(show f)
(show c)
(show s)
(show h)
(show b)
(show o)

;; (define (main -> Int)
;;   "Program's entry pont."
;;   (show "Hello, World"))

(show "Test Showing Int + <T>")
(show (+ i i))
(show (+ i f))
(show (+ i c))
;; (show (+ i s))
(show (+ i h))
(show (+ i b))
(show (+ i o))

(show "Test Showing Float + <T>")
(show (+ f i))
(show (+ f f))
(show (+ f c))
;; (show (+ f s))
(show (+ f h))
(show (+ f b))
(show (+ f o))

(show "Testing Showing Char + <T>")
(show (+ c i))
(show (+ c f))
(show (+ c c))
;; (show (+ c s))
(show (+ c h))
(show (+ c b))
(show (+ c o))

(show "Testing Showing String + <T>")
;; (show (+ s i))
;; (show (+ s f))
;; (show (+ s c))
;; (show (+ s s))
;; (show (+ s h))
;; (show (+ s b))
;; (show (+ s o))

(show "Testing Showing Hex + <T>")
(show (+ h i))
(show (+ h f))
(show (+ h c))
;; (show (+ h s))
(show (+ h h))
;; (show (+ h b))
;; (show (+ h o))

(show "Testing Showing Bin + <T>")
(show (+ b i))
(show (+ b f))
(show (+ b c))
;; (show (+ b s))
;; (show (+ b h))
(show (+ b b))
;; (show (+ b o))

(show "Testing Showing Oct + <T>")
(show (+ o i))
(show (+ o f))
(show (+ o c))
;; (show (+ o s))
;; (show (+ o h))
;; (show (+ o b))
(show (+ o o))

;; (show (+ 3.0 0.5))
;; (show (- 1 3))
;; (show "Hello, World")
;; (show '(+ 2 2))
;; (show '(+ 2 2))

;;; Functions

(define x 30
  "doc")

(define square (lambda ([x :: Int] -> Int) "doc" (* x x)))


(define (multi [x :: Int] -> [y :: Int] -> Int)
  "Multiply X and Y as Ints"
  (* x y))

(define (multf [x :: Float] -> [y :: Float] -> Float)
  "Multiply X and Y as Floats"
  (* x y))

(define (multc [x :: Char] -> [y :: Char] -> Int)
  "Multiply X and Y as Chars"
  (* x y))

(define (multo [x :: Oct] -> [y :: Oct] -> Oct)
  "Multiply X and Y as Hexs, return Oct"
  (* x y))

(define (multb [x :: Bin] -> [y :: Bin] -> Bin)
  "Multiply X and Y as Hexs, return Hex"
  (* x y))

;; It should be smart enoguh
(define (multh [x :: Hex] -> [y :: Hex] -> Hex)
  "Multiply X and Y as Hexs, return Hex"
  (* x y))

(define (multh [x :: Hex] -> [y :: Hex] -> Hex)
  "Multiply X and Y as Hexs, return Hex"
  (* x y))

(define (multhi [x :: Hex] -> [y :: Hex] -> Int)
  "Multiply X and Y as Hexs, return Int"
  (* x y))

(show "Shwing result of multh")
(define result (multh h h))
(define result2 (multhi h h))
(show result)
(show result2)
(show "HERE")
(show 0xFF)
(show 0b1010)
(show 0o755)
(show 10)
;; (show 1e6)
(show "ALSO HERE")
;; (show (Int (+ b b)))


(define [decimal :: Float] 0.132093)
;; (define [frac :: Fraction] 1/3) TODO

; if i call this resulti it segfault

;; (define (multhi [x :: Hex] -> [y :: Hex] -> Int)
;;   "Multiply X and Y as Hexs, return Int"
;;   (* x y))

;;; Optional parameters

;; ;; Here Y is optiona because it's after => (defaults to False)
;; (define (multh [x :: Hex] => [y :: Hex] -> Int)
;;   "Multiply X and Y as Hexs"
;;   (* x y))

;; ;; Here all the parameters are optional Y defaults to 3 if not provided
;; (define (multh => [x :: Hex] -> [y :: Hex 3] -> [z :: Hex] -> Int)
;;   "Multiply X and Y as Hexs"
;;   (* x y))

;; ;; Here X is optional and defaults to False
;; (define (multh => [x :: Hex] -> Int)
;;   "Multiply X and Y as Hexs"
;;   (* x y))



(show "Testing calling user define functions")
(show (square 10))
(show (multi f f))
(show (multf i i))
(show (multc 'A' 'A'))
(show (multh 0xFF 0xFF))
;; (doc 'multi)


;;; Asm

;; The major-mode will do asm syntax highlighting inside this expression

;; (asm
;;   push %rbp
;;   mov  %rsp, %rbp
;;   pop  %rbp
;; )

;;; Types as types

;; ;; NOTE Returning the casted result of x
;; (define (cast-with-type [t :: T] -> [x :: Int] -> t)
;;   "Cast X with type T"
;;   (t x))

;; ;; NOTE Returning the String type itself
;; (define (string-type -> [String :: T])
;;   "Return the String type"
;;   (String))

;; (cast-with-type (string-type) 3); => "3"

;; Applying a type as function call has 2 different behaviors
;; - if called with arguments it will cast those arguments
;; - if called without arguments it will return the type itself

;;; Typed expressions

; This is sayn the expression (+ b b) is of type Bin
;; [(+ b b) :: Bin]


;; (define (id x) x)

;; (define (fid [f :: Fn] -> Fn)
;;   f)

;; (moogle ([f :: Fn] -> x)); -> [apply :: Fn]

;; ((moogle ([f :: Fn] -> x)) double 3)
;; (apply double 3)

;; (define (apply [f :: Fn] -> x)
;;   (f x))


;; (Int +); -> 43
;; (Int apply); -> 550

;;; TODO Casting
;; Applying types as functions
;; result in a cast (for builtin types)

;; (Int 20)        ; => 20       (From Int) [id]
;; (Int 40.3)      ; => 40       (From Float)
;; (Int 'A')       ; => 65       (From Char)
;; (Int "hi")      ; => 209      (From String)
;; (Int 0xFF)      ; => 255      (From Hex)
;; (Int 0b1010)    ; => 10       (From Bin)
;; (Int 0o755)     ; => 493      (From Oct)
;; (Int +)         ; => #hash    (From Fn)
;; (Int 1/3)       ; => 0        (From Fraction)

;; (Float 20)      ; => 20.0     (From Int)
;; (Float 40.3)    ; => 40.3     (From Float) [id]
;; (Float 'A')     ; => 65.0     (From Char)
;; (Float "hi")    ; => 209.0    (From String)
;; (Float 0xFF)    ; => 255.0    (From Hex)
;; (Float 0b1010)  ; => 10.0     (From Bin)
;; (Float 0o755)   ; => 493.0    (From Oct)
;; (Float +)       ; => C ERROR  (From Fn)
;; (Float 1/3)     ; => 0.33333  (From Fraction)

;; (Char 65)       ; => 'A'      (From Int)
;; (Char 66.3)     ; => 'B'      (From Float)
;; (Char 'A')      ; => 'A'      (From Char) [id]
;; (Char "hi")     ; => 'Ñ'      (From String)
;; (Char 0xFF)     ; => 'ÿ'      (From Hex)
;; (Char 0b1010)   ; => '\n'     (From Bin)
;; (Char 0o755)    ; => 'ǭ'      (From Oct)
;; (Char +)        ; => C ERROR  (From Fn)
;; (Char 1/3)      ; => C ERROR  (From Fraction)

;; (String 65)     ; => "A"      (From Int)
;; (String 66.3)   ; => "B"      (From Float)
;; (String 'A')    ; => "A"      (From Char)
;; (String "hi")   ; => "hi"     (From String) [id]
;; (String 0xFF)   ; => "0xFF"   (From Hex)
;; (String 0b1010) ; => "0b1010" (From Bin)
;; (String 0o755)  ; => "0o755"  (From Oct)
;; (String +)      ; => "+"      (From Fn)
;; (String 1/3)    ; => "1/3"    (From Fraction)

;; (Hex 65)        ; => 0x41     (From Int)
;; (Hex 66.3)      ; => 0x42     (From Float)
;; (Hex 'A')       ; => 0x41     (From Char)
;; (Hex "hi")      ; => 0xd1     (From String)
;; (Hex 0xFF)      ; => 0xFF     (From Hex) [id]
;; (Hex 0b1010)    ; => 0xa      (From Bin)
;; (Hex 0o755)     ; => 0x1ed    (From Oct)
;; (Hex +)         ; => #hash    (From Fn)
;; (Hex 1/3)       ; => C ERROR  (From Fraction)

;; (Bin 65)        ; => 0b1000001   (From Int)
;; (Bin 66.3)      ; => 0b1000010   (From Float)
;; (Bin 'A')       ; => 0b1000001   (From Char)
;; (Bin "hi")      ; => 0b11010001  (From String)
;; (Bin 0xFF)      ; => 0b11111111  (From Hex)
;; (Bin 0b1010)    ; => 0b1010      (From Bin) [id]
;; (Bin 0o755)     ; => 0b111101101 (From Oct)
;; (Bin +)         ; => #hash       (From Fn)
;; (Bin 1/3)       ; => C ERROR     (From Fraction)

;; (Oct 65)        ; => 0o101    (From Int)
;; (Oct 66.3)      ; => 0o50     (From Float)
;; (Oct 'A')       ; => 0o101    (From Char)
;; (Oct "hi")      ; => 0o321    (From String)
;; (Oct 0xFF)      ; => 0o377    (From Hex)
;; (Oct 0b1010)    ; => 0o12     (From Bin)
;; (Oct 0o755)     ; => 0o755    (From Oct) [id]
;; (Oct +)         ; => #hash    (From Fn)
;; (Oct 1/3)       ; => C ERROR  (From Fraction)

;; (Fn 20)        ; => (lambda () 20)     (From Int)
;; (Fn 40.3)      ; => (lambda () 40.3)   (From Float)
;; (Fn 'A')       ; => (lambda () 'A')    (From Char)
;; (Fn "hi")      ; => (lambda () "Hi")   (From String)
;; (Fn 0xFF)      ; => (lambda () 0xFF)   (From Hex)
;; (Fn 0b1010)    ; => (lambda () 0b1010) (From Bin)
;; (Fn 0o755)     ; => (lambda () 0o755)  (From Oct)
;; (Fn +)         ; => +                  (From Fn) [id]
;; (Fn 1/3)       ; => (lambda () 1/3)    (From Fraction)

;; (Fraction 20)        ; => 20/1     (From Int)
;; (Fraction 40.3)      ; => C ERROR  (From Float)
;; (Fraction 'A')       ; => 65/1     (From Char)
;; (Fraction "hi")      ; => 209/1    (From String)
;; (Fraction 0xFF)      ; => 255/1    (From Hex)
;; (Fraction 0b1010)    ; => 10/1     (From Bin)
;; (Fraction 0o755)     ; => 493/1    (From Oct)
;; (Fraction +)         ; => C ERROR  (From Fn)
;; (Fraction 1/3)       ; => 1/3      (From Fraction) [id]


;; Since we use HM type system
;; we can infer function names based on type.
;; (define (int->hex [x :: Int] -> Hex)
;;   (Hex x))


;; (define (last coll)
;;   (match coll
;;     [] -> (error "Empty collection")
;;     [x] -> x
;;     [_|xs] -> (last xs)))

;; (define (last coll -> [a :: Maybe])
;;   (match coll
;;     [] -> Nothing
;;     [x] -> [x :: Just]
;;     [_|xs] -> (last xs)))


;; Write it in a generic way
;; (define (double x)
;;   (* x x))

;; ;; Based on use
;; (double 3)
;; (double 2.5)

;; ;; [[https://en.wikipedia.org/wiki/Parametric_polymorphism][Parametric polymorphism]]
;; ;;  It will under the hood generate 2 functions,
;; ;;  because i've use it on an int and float
;; ;;  If i were to use it on other types too,
;; ;;  it would generate more.

;; (define (double [x :: Int] -> Int)
;;   (* x x))

;; (define (double [x :: Float] -> Float)
;;   (* x x))

;;; Layout

;; (layout Point
;;   [x :: F32]
;;   [y :: F32])

;; (define p (Point 33 22)); will be inferred as [p :: Point]
;; (define [p :: Point] (Point 33 22)); Manually typed

;; ; This is always possible even if it doesn't derive Show
;; (show Point); => (layout Point
;; ;                  [x :: F32]
;; ;                  [y :: F32])


;;; Repl output

;; [+ :: Fn (=> _ _ . _)]
;; [cons :: Fn (_ _)]
;; [not :: Fn (_)]
;; [make-vector :: Fn (_ => _)]
;; [substring :: Fn (_ _ => _)]
;; [apply :: Fn (_ _ . _)]
;; [list :: Fn _]; Same as (=> . _)
